/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2006, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: MeanPollambda_monitor
*
* %I
* Written by: Peter Christiansen
* Date: July 2006
* Origin: Risoe
*
* Polarisation and wavelength sensitive monitor.
*
* %D A square single monitor that measures the MEAN projection of the
* polarisation along a given normalized m-vector (mx, my, mz) as a
* function of wavelength.
* Mean and variance algorithm adapted from:
*   West. 1979. Updating mean and variance estimates: an improved method. Commun. ACM 22, 9 (Sept. 1979)
*
* Example: MeanPollambda_monitor(xwidth=0.1, yheight=0.1, npol=11, my=1, filename="meanpollambdaMon.data")
*
* %P
* INPUT PARAMETERS:
*
* xwidth: [m]           Width of detector 
* yheight: [m]          Height of detector 
* mx: [1]               X-component of monitor vector (can be negative) 
* my: [1]               Y-component of monitor vector (can be negative) 
* mz: [1]               Z-component of monitor vector (can be negative) 
* nL: [1]               Number of bins in wavelength 
* Lmin: [AA]            Minimum wavelength detected 
* Lmax: [AA]            Maximum wavelength detected 
* filename: [string]    Name of file in which to store the data 
* restore_neutron: [1]  If set, the monitor does not influence the neutron state 
* nowritefile: [1]      If set, monitor will skip writing to disk
*
* OUTPUT PARAMETERS:
*
* PolL_N: [1]           Array of neutron counts 
* PolL_p: [1]           Array of neutron weight counts 
* PolL_p2: [1]          Array of second moments 
* HelpArray: [1]        Array of weight counts used for normalization 
*
* %E
*******************************************************************************/

DEFINE COMPONENT MeanPolLambda_monitor

DEFINITION PARAMETERS (xwidth=0.1, yheight=0.1, nL=20, restore_neutron=0, int nowritefile=0)

SETTING PARAMETERS (string filename, mx=0, my=0, mz=0, Lmin, Lmax)

OUTPUT PARAMETERS (PolL_N, PolL_p, PolL_p2, PolL_w, PolL_w2, PolL_wp)
/* Neutron parameters: (x,y,z,vx,vy,vz,t,sx,sy,sz,p) */

DECLARE
%{
  double PolL_N[nL];
  double PolL_T[nL];
  double PolL_W[nL];
  double PolL_W2[nL];
  double PolL_M[nL];
%}

INITIALIZE
%{
  int i;

  // Check that input parameteters makes sense

  if (Lmax<=Lmin) {
    fprintf(stderr, "Pol_monitor: %s: l1 <= l0!\n"
        "ERROR. Exiting",
        NAME_CURRENT_COMP);
    exit(1);
  }

  if (mx==0 && my==0 && mz==0) {
    fprintf(stderr, "Pol_monitor: %s: NULL vector defined!\n"
        "ERROR      (mx, my, mz). Exiting",
        NAME_CURRENT_COMP);
    exit(1);
  }

  if ((xwidth<=0) || (yheight <= 0)) {
    fprintf(stderr, "Pol_monitor: %s: Null detection area !\n"
        "ERROR      (xwidth,yheight). Exiting",
        NAME_CURRENT_COMP);
    exit(1);
  }

  // Initialize variables

  NORM(mx, my, mz);

  for (i=0; i<nL; i++) {
    PolL_N[i] = 0;
    PolL_W[i] = 0;
    PolL_T[i] = 0;
    PolL_M[i] = 0;
  }
%}

TRACE
%{
  int i;
  double pol_proj;
  double lambda;

  PROP_Z0;
  lambda = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);

  if (inside_rectangle(x, y, xwidth, yheight) &&
      lambda > Lmin && lambda < Lmax) {

    pol_proj = scalar_prod(mx, my, mz, sx, sy, sz);

    i= floor((lambda - Lmin)*nL/(Lmax - Lmin));

    /*update the samples according to West's algorithm*/
    if(PolL_N[i]==0){
      PolL_M[i]=pol_proj;
      PolL_W[i]=p;
      PolL_W2[i]=p*p;
      PolL_T[i]=0;
    }else{
      double R,Q;
      double TT,dt;
      TT=PolL_W[i]; /*previous weight sum*/
      PolL_W[i]+=p; /*West temp*/
      PolL_W2[i]+=p*p;
      Q=(pol_proj- PolL_M[i]);
      R=Q * p / PolL_W[i];
      PolL_M[i] += R;
      dt= Q * R * TT;
      PolL_T[i] += dt;
    }
    PolL_N[i]++;

    SCATTER;
  }
  if (restore_neutron) {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
%}

SAVE
%{
  if (!nowritefile) {
    int j;
    double mpifactor=1;
    double error[nL];

    MCDETECTOR mcd;
    /*call imcdetector_import to formalize structure and do MPI-reduction as normal.*/
    mcd=mcdetector_import(mcformat, NAME_CURRENT_COMP, "Pol-wavelength monitor", 
        nL, 1, 1, 
        "Wavelength [AA]", "Mean Polarisation",(nL > 1 ? "Signal per bin" : " Signal"), 
        "Wavelength", "(I,I_err)", "I",
        Lmin,Lmax, 0, 0, 0, 0, filename,
        &PolL_N[0],&PolL_M[0],&PolL_T[0], POS_A_CURRENT_COMP);

    /*mpi-reduce on the weighted arrays if necessary*/
#ifdef USE_MPI

#endif
    
    /* Rewrite the mean signal slot and the error slot in the mcdetector struct. mcdetector_import puts these
       in p1 as a 1d-array with sets of four numbers in a row: [x0, y0, ye0, N0, x1, y1, ...., yen, Nn].*/
    for (j=0;j<nL;j++){
      /*overwrite with weighted mean*/
      mcd.p1[j*4+1]=PolL_M[j];
      /*overwrite with weighted and frequency corrected stddev*/
      mcd.p1[j*4+2]=sqrt(fabs(PolL_T[j])*PolL_N[j]/(PolL_N[j]-1)*PolL_W[j]);
    }

#ifdef USE_NEXUS
  if (strcasestr(detector.format, "NeXus"))
   mcdetector_out_1D_nexus(mcd);
  else
#endif
    mcdetector_out_1D_ascii(mcd);
  }
%}

MCDISPLAY
%{
  
  rectangle("xy", 0, 0, 0, xwidth, yheight);
%}

END
